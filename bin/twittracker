#!/usr/bin/env node

// DB setup

var mongoose = require('mongoose');
require('../mongosetup.js');
var TwitterPost = require('../models/twitter-post.js');
var Twitter = require('twit');
var Strint = require("../util/strint"); 
 
// NOTE: we use Strint to process twitter IDs as strings, because they are too big for Numbers.
// Javascript can only handle 53 bit integers, and Twitter IDs are 64 bit
 
var twit = new Twitter({
  consumer_key:         process.env.TW_API_KEY,
  consumer_secret:      process.env.TW_API_SECRET,
  access_token:         process.env.TW_TOKEN,
  access_token_secret:  process.env.TW_TOKEN_SECRET
})

var max_tweet_results = 10000; // limit calling the api at 100 calls (100 results x 100 calls = 10000)


//
//  function getTweets - make recursive calls to Twitter to get all relevant results (100 per call)
//

var getTweets = function( max_id ) {
  var search_params = {
    q:            '#servicedesign OR "service design"', 
    count:        100, 
    result_type:  'recent',
    geocode:      '"52.5 -1.5 200km"',
    tweet_mode:   'extended' 
  }
  if (max_id != undefined) search_params.max_id = max_id;
    
  // get first 100 tweets 
  var tw_call_1 = twit.get('search/tweets', search_params);
  
  // if there's more, call API again to get next 'page'
  var tw_call_2 = tw_call_1.then( result => {
    if (result.data.statuses.length > 0 || result.data.statuses.length > max_tweet_results) {
      // get min_id from all current ids and pass that to next twitter call (through a recursive getTweets) as max_id
      var ids = result.data.statuses.map( status => status.id_str );
      var min_id = ids.reduce( (a, b) => { return Strint.lt(a,b) ? a : b; });

      return getTweets(Strint.sub(min_id,'1'));
    }
    else return result;
  });

  // merge statuses from this and from next call to twitter API
  return Promise.all([tw_call_1, tw_call_2]).then( ([result_1, result_2]) => {
      var new_statuses = [ ...result_1.data.statuses, ...result_2.data.statuses ];      
      result_1.data.statuses = new_statuses;
      return result_1;
  });
  
}



//
//  Main - call twitter then write to database
//


TwitterPost.init()
.then(function() {

  var twitter_call = getTweets();

  // after twitter call, check for exsiting tweets (IDs) â€“ check if any duplicates are already saved in database
  var check_existing = twitter_call.then( result => {
    return TwitterPost.find({'id_str': { $in: result.data.statuses.map( status => status.id_str) }}, 'id_str');
  });

  // after both calls (to twitter and to database), remove existing tweets from twitter results and return that
  return Promise.all([twitter_call, check_existing]).then(function([result, existing_posts]) {
    var existing_ids = existing_posts.map(post => post.id_str);

    // filter out tweets with ids that exist in database
    result.data.statuses = result.data.statuses.filter( status => !existing_ids.includes(status.id_str) );

    return result;
  });
  
}) 
.then(function (result) {
  // save remaining tweets to database
  console.log("NEW RECORDS CREATED: " + result.data.statuses.length);
  return TwitterPost.insertMany(result.data.statuses);
  return result;
})
.then(function() {
    mongoose.disconnect();
})
.catch(function (err) {
  console.log(err.stack);
  mongoose.disconnect();
});
